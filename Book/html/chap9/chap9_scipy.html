<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>9. Numerical Routines: SciPy and NumPy &mdash; PyMan 0.9.31 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.31',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="PyMan 0.9.31 documentation" href="../index.html" />
    <link rel="next" title="10. Installing Python" href="../apdx1/apdx1_install.html" />
    <link rel="prev" title="8. Curve Fitting" href="../chap8/chap8_fitting.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../pymanMaster.html">PyMan 0.9.31 documentation</a></div>
        <div class="rel">
          <a href="../chap8/chap8_fitting.html" title="8. Curve Fitting"
             accesskey="P">previous</a> |
          <a href="../apdx1/apdx1_install.html" title="10. Installing Python"
             accesskey="N">next</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="numerical-routines-scipy-and-numpy">
<span id="chap9"></span><h1>9. Numerical Routines: SciPy and NumPy<a class="headerlink" href="#numerical-routines-scipy-and-numpy" title="Permalink to this headline">¶</a></h1>
<p>SciPy is a Python library of mathematical routines.  Many of the SciPy routines are Python &#8220;wrappers&#8221;, that is, Python routines that provide a Python interface for numerical libraries and routines originally written in Fortran, C, or C++.  Thus, SciPy lets you take advantage of the decades of work that has gone into creating and optimizing numerical routines for science and engineering.  Because the Fortran, C, or C++ code that Python accesses is compiled, these routines typically run very fast.  Therefore, there is no real downside&#8212;no speed penalty&#8212;for using Python in these cases.</p>
<p id="index-0">We have already encountered one of SciPy&#8217;s routines, <tt class="docutils literal"><span class="pre">scipy.optimize.leastsq</span></tt>, for fitting nonlinear functions to experimental data, which was introduced in the the chapter on <a class="reference internal" href="../chap8/chap8_fitting.html#chap8"><em>Curve Fitting</em></a>.   Here we will provide a further introduction to a number of other SciPy packages, in particular those on special functions, numerical integration, including routines for numerically solving ordinary differential equations (ODEs), discrete Fourier transforms, linear algebra, and solving non-linear equations.  Our introduction to these capabilities does not include extensive background on the numerical methods employed; that is a topic for another text.  Here we simply introduce the SciPy routines for performing some of the more frequently required numerical tasks.</p>
<p>One final note:  SciPy makes extensive use of NumPy arrays, so NumPy should always be imported with SciPy</p>
<div class="section" id="special-functions">
<span id="specfunc"></span><span id="index-1"></span><h2>9.1. Special functions<a class="headerlink" href="#special-functions" title="Permalink to this headline">¶</a></h2>
<p>SciPy provides a plethora of special functions, including Bessel functions (and routines for finding their zeros, derivatives, and integrals), error functions, the gamma function, Legendre, Laguerre, and Hermite polynomials (and other polynomial functions), Mathieu functions, many statistical functions, and a number of other functions.  Most are contained in the <tt class="docutils literal"><span class="pre">scipy.special</span></tt> library, and each has its own special arguments and syntax, depending on the vagaries of the particular function.  We demonstrate a number of them in the code below that produces a plot of the different functions called.  For more information, you should consult the SciPy web site on the <tt class="docutils literal"><span class="pre">scipy.special</span></tt> library.</p>
<blockquote>
<div><div class="figure align-center" id="fig-specfuncplots">
<a class="reference internal image-reference" href="../_images/specFuncPlots.jpg"><img alt="../_images/specFuncPlots.jpg" src="../_images/specFuncPlots.jpg" style="width: 800.0px; height: 711.0px;" /></a>
<p class="caption">Plots of a few selected special functions</p>
</div>
</div></blockquote>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84</pre></div></td><td class="code"><div class="highlight"><pre>    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">scipy.special</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

    <span class="c"># create a figure window</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

    <span class="c"># create arrays for a few Bessel functions and plot them</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">j0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">jn</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">j1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">jn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">yn</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">yn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">j0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span><span class="s">&#39;Bessel&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s">&#39;top&#39;</span><span class="p">,</span>
         <span class="n">transform</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="c"># gamma function</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mi">3601</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
    <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">322</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">g</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">3.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span><span class="s">&#39;Gamma&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s">&#39;top&#39;</span><span class="p">,</span>
         <span class="n">transform</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="c"># error function</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">ef</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">323</span><span class="p">)</span>
    <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">ef</span><span class="p">)</span>
    <span class="n">ax3</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.1</span><span class="p">)</span>
    <span class="n">ax3</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span><span class="s">&#39;Error&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s">&#39;top&#39;</span><span class="p">,</span>
         <span class="n">transform</span> <span class="o">=</span> <span class="n">ax3</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="c"># Airy function</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">ai</span><span class="p">,</span> <span class="n">aip</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">bip</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">airy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">324</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">ai</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">bi</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.6</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span><span class="s">&#39;Airy&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s">&#39;top&#39;</span><span class="p">,</span>
         <span class="n">transform</span> <span class="o">=</span> <span class="n">ax4</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="c"># Legendre polynomials</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">lp0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">legendre</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="n">lp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">legendre</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="n">lp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">legendre</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="n">lp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">legendre</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">325</span><span class="p">)</span>
    <span class="n">ax5</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">lp0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">lp1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">lp2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">lp3</span><span class="p">)</span>
    <span class="n">ax5</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax5</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax5</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">)</span>
    <span class="n">ax5</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span><span class="s">&#39;Legendre&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s">&#39;top&#39;</span><span class="p">,</span>
         <span class="n">transform</span> <span class="o">=</span> <span class="n">ax5</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="c"># Laguerre polynomials</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
    <span class="n">lg0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">laguerre</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="n">lg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">laguerre</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="n">lg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">laguerre</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="n">lg3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">laguerre</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ax6</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">326</span><span class="p">)</span>
    <span class="n">ax6</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">lg0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">lg1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">lg2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">lg3</span><span class="p">)</span>
    <span class="n">ax6</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax6</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&quot;grey&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax6</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">ax6</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">ax6</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span><span class="s">&#39;Laguerre&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s">&#39;top&#39;</span><span class="p">,</span>
         <span class="n">transform</span> <span class="o">=</span> <span class="n">ax6</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>The arguments of the different functions depend, of course, on the nature of the particular function.  For example, the first argument of the two types of Bessel functions called in lines 10-13 is the so-called <em>order</em> of the  Bessel function, and the second argument is the independent variable.  The Gamma and Error functions take one argument each and produce one output.  The Airy function takes only one input argument, but returns four outputs, which correspond the two Airy functions, normally designated <img class="math" src="../_images/math/fa7e1e38606e489d6e92146f20c30c208b308fa8.png" alt="\mathrm{Ai}(x)"/> and <img class="math" src="../_images/math/b35b8fe37f5725ed0aae3e12a6d1b7070fc9c3fd.png" alt="\mathrm{Bi}(x)"/>, and their derivatives <img class="math" src="../_images/math/d22633c65ff8e55186fc264f4217b3fbb90fea7b.png" alt="\mathrm{Ai}^\prime(x)"/> and <img class="math" src="../_images/math/c2552d0235d46afe22e605670924aa0d9c86c886.png" alt="\mathrm{Bi}^\prime(x)"/>.  The plot shows only <img class="math" src="../_images/math/fa7e1e38606e489d6e92146f20c30c208b308fa8.png" alt="\mathrm{Ai}(x)"/> and <img class="math" src="../_images/math/b35b8fe37f5725ed0aae3e12a6d1b7070fc9c3fd.png" alt="\mathrm{Bi}(x)"/>.</p>
<p>The polynomial functions shown have a special syntax that uses NumPy&#8217;s <tt class="docutils literal"><span class="pre">polyval</span></tt> function for generating polynomials.  If <tt class="docutils literal"><span class="pre">p</span></tt> is a list or array of <tt class="docutils literal"><span class="pre">N</span></tt> numbers and <tt class="docutils literal"><span class="pre">x</span></tt> is an array, then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span>
                 <span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>For example, if <tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">[2.0,</span> <span class="pre">5.0,</span> <span class="pre">1.0]</span></tt>, <tt class="docutils literal"><span class="pre">polyval(p,</span> <span class="pre">x)</span></tt> generates the following quadratic polynomial: <img class="math" src="../_images/math/d284b37ca49dddbfd6fc5f63aec0019431c80352.png" alt="2x^2 + 5x +1"/>.</p>
<p>SciPy&#8217;s <tt class="docutils literal"><span class="pre">special.legendre(n)</span></tt> and <tt class="docutils literal"><span class="pre">special.laguerre(n)</span></tt> functions output the coefficients <tt class="docutils literal"><span class="pre">p</span></tt> needed in <tt class="docutils literal"><span class="pre">polyval</span></tt> to produce the <img class="math" src="../_images/math/1a3679aec3dfb0f6adda3d47ea8364d642a9e903.png" alt="n^\mathrm{th}"/>-order Legendre and Laguerre polynomials, respectively.  The <tt class="docutils literal"><span class="pre">scipy.special</span></tt> library has functions that specify many other polynomial functions in this same way.</p>
</div>
<div class="section" id="numerical-integration">
<span id="numericalintegration"></span><span id="index-2"></span><h2>9.2. Numerical integration<a class="headerlink" href="#numerical-integration" title="Permalink to this headline">¶</a></h2>
<p>When a function cannot be integrated analytically, or is very difficult to integrate analytically, one generally turns to numerical integration methods.   SciPy has a number of routines for performing numerical integration.  Most of them are found in the same <tt class="docutils literal"><span class="pre">scipy.integrate</span></tt> library.  We list them here for reference.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Function</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">quad</span></tt></td>
<td>single integration</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">dblquad</span></tt></td>
<td>double integration</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">tplquad</span></tt></td>
<td>triple integration</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">nquad</span></tt></td>
<td><img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>-fold multiple integration</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">fixed_quad</span></tt></td>
<td>Gaussian quadrature, order n</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">quadrature</span></tt></td>
<td>Gaussian quadrature to tolerance</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">romberg</span></tt></td>
<td>Romberg integration</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">trapz</span></tt></td>
<td>trapezoidal rule</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">cumtrapz</span></tt></td>
<td>trapezoidal rule to cumulatively compute integral</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">simps</span></tt></td>
<td>Simpson&#8217;s rule</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">romb</span></tt></td>
<td>Romberg integration</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">polyint</span></tt></td>
<td>Analytical polynomial integration (NumPy)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">poly1d</span></tt></td>
<td>Helper function for <tt class="docutils literal"><span class="pre">polyint</span></tt> (NumPy)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="section" id="single-integrals">
<h3>9.2.1. Single integrals<a class="headerlink" href="#single-integrals" title="Permalink to this headline">¶</a></h3>
<p>The function <tt class="docutils literal"><span class="pre">quad</span></tt> is the workhorse of SciPy&#8217;s integration functions. Numerical integration is sometimes called <em>quadrature</em>, hence the name.  It is normally the default choice for performing single integrals of a function <img class="math" src="../_images/math/14546c27a7b929642f7840acca5f851c503ea109.png" alt="f(x)"/> over a given fixed range from <img class="math" src="../_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/> to <img class="math" src="../_images/math/5e87bf41a96deddf6cb485ff530f153f2590e9cc.png" alt="b"/></p>
<div class="math">
<p><img src="../_images/math/4419abde6636759d4887b69d3f4be410e960713e.png" alt="\int_a^b f(x)\, dx"/></p>
</div><p>The general form of <tt class="docutils literal"><span class="pre">quad</span></tt> is <tt class="docutils literal"><span class="pre">scipy.integrate.quad(f,</span> <span class="pre">a,</span> <span class="pre">b)</span></tt>, where <tt class="docutils literal"><span class="pre">f</span></tt> is the name of the function to be integrated and <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are the lower and upper limits, respectively.  The routine uses <em>adaptive quadrature</em> methods to numerically evaluate integrals, meaning it successively refines the subintervals (makes them smaller) until a desired level of numerical precision is achieved.  For the <tt class="docutils literal"><span class="pre">quad</span></tt> routine, this is about <img class="math" src="../_images/math/21657abf2dea8e36fed8ad9de97c6a7d36bb6953.png" alt="10^{-8}"/>, although it usually does even better.</p>
<p>As an example, let&#8217;s integrate a Gaussian function over the range from 0 to 1</p>
<div class="math">
<p><img src="../_images/math/3f6dfd6f5213e681c5e9730e129872ec2c7f8560.png" alt="\int_0^1 e^{-x^2} dx"/></p>
</div><p>We first need to define the function <img class="math" src="../_images/math/e8aa26af7c67f550f2ab2863898ebadac6d4558b.png" alt="f(x)=e^{-x^2}"/>, which we do using a lambda expression, and then we call the function <tt class="docutils literal"><span class="pre">quad</span></tt> to perform the integration.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">scipy.integrate</span>

<span class="gp">In [2]: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gr">Out[3]: </span><span class="p">(</span><span class="mf">0.7468241328124271</span><span class="p">,</span> <span class="mf">8.291413475940725e-15</span><span class="p">)</span>
</pre></div>
</div>
<p>The function call <tt class="docutils literal"><span class="pre">scipy.integrate.quad(f,</span> <span class="pre">0,</span> <span class="pre">1)</span></tt> returns two numbers.  The first is <tt class="docutils literal"><span class="pre">0.7468...</span></tt>, which is the value of the integral, and the second is <tt class="docutils literal"><span class="pre">8.29...e-15</span></tt>, which is an estimate of the absolute error in the value of the integral, which we see is quite small compared to <tt class="docutils literal"><span class="pre">0.7468</span></tt>.</p>
<p>Because <tt class="docutils literal"><span class="pre">quad</span></tt> requires a function <em>name</em> as its first argument, we can&#8217;t simply use the expression <tt class="docutils literal"><span class="pre">exp(-x**2)</span></tt>.  On the other hand, we could use the usual <tt class="docutils literal"><span class="pre">def</span></tt> statement to create a normal function, and then use the name of that function in <tt class="docutils literal"><span class="pre">quad</span></tt>.  However, it&#8217;s simpler here to use a lambda expression.  In fact, we can just put the lambda expression directly into the first argument, as illustrated here</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [4]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gr">Out[4]: </span><span class="p">(</span><span class="mf">0.7468241328124271</span><span class="p">,</span> <span class="mf">8.291413475940725e-15</span><span class="p">)</span>
</pre></div>
</div>
<p>That works too!  Thus we see a <tt class="docutils literal"><span class="pre">lambda</span></tt> expression used as an <em>anonymous function</em>, a function with no name, as promised in the section <a class="reference internal" href="../chap7/chap7_funcs.html#lambda"><em>Anonymous functions (lambda)</em></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">quad</span></tt> function accepts positive and negative infinity as limits.</p>
</div>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span>
<span class="gr">Out[5]: </span><span class="p">(</span><span class="mf">0.8862269254527579</span><span class="p">,</span> <span class="mf">7.101318390472462e-09</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gr">Out[6]: </span><span class="p">(</span><span class="mf">1.6330510582651852</span><span class="p">,</span> <span class="mf">3.669607414547701e-11</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">quad</span></tt> function handles infinite limits just fine. The absolute errors are somewhat larger but still well within acceptable bounds for practical work.</p>
<p>The <tt class="docutils literal"><span class="pre">quad</span></tt> function can integrate standard predefined NumPy functions of a single variable, like <tt class="docutils literal"><span class="pre">exp</span></tt>, <tt class="docutils literal"><span class="pre">sin</span></tt>, and <tt class="docutils literal"><span class="pre">cos</span></tt>.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [7]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gr">Out[7]: </span><span class="p">(</span><span class="mf">1.7182818284590453</span><span class="p">,</span> <span class="mf">1.9076760487502457e-14</span><span class="p">)</span>

<span class="gp">In [8]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gr">Out[8]: </span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.707864644566304e-15</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gr">Out[9]: </span><span class="p">(</span><span class="mf">0.9588510772084061</span><span class="p">,</span> <span class="mf">1.0645385431034061e-14</span><span class="p">)</span>
</pre></div>
</div>
<p>Let&#8217;s integrate the first order Bessel function of the first kind, usually denoted <img class="math" src="../_images/math/2c19f326e63311371841c23ef7d61840aeac9520.png" alt="J_1(x)"/>, over the interval from 0 to 5.  Here is how we do it, using <tt class="docutils literal"><span class="pre">scipy.special.jn(v,x)</span></tt> where <tt class="docutils literal"><span class="pre">v</span></tt> is the (real) order of the Bessel function:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [10]: </span><span class="kn">import</span> <span class="nn">scipy.special</span>

<span class="gp">In [11]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">jn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gr">Out[11]: </span><span class="p">(</span><span class="mf">1.177596771314338</span><span class="p">,</span> <span class="mf">1.8083362065765924e-14</span><span class="p">)</span>
</pre></div>
</div>
<p>Because the SciPy function <tt class="docutils literal"><span class="pre">scipy.special.jn(v,</span> <span class="pre">x)</span></tt> is a function of two variables, <tt class="docutils literal"><span class="pre">v</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>, we cannot use the function name <tt class="docutils literal"><span class="pre">scipy.special.jn</span></tt> in <tt class="docutils literal"><span class="pre">quad</span></tt>.  So we use a <tt class="docutils literal"><span class="pre">lambda</span></tt> expression, which is a function of only one variable, <tt class="docutils literal"><span class="pre">x</span></tt>, because we have set the <tt class="docutils literal"><span class="pre">v</span></tt> argument equal to 1.</p>
<div class="section" id="integrating-polynomials">
<span id="index-3"></span><h4>9.2.1.1. Integrating polynomials<a class="headerlink" href="#integrating-polynomials" title="Permalink to this headline">¶</a></h4>
<p>Working in concert with the NumPy <tt class="docutils literal"><span class="pre">poly1d</span></tt>, the NumPy function <tt class="docutils literal"><span class="pre">polyint</span></tt> takes the <img class="math" src="../_images/math/1a3679aec3dfb0f6adda3d47ea8364d642a9e903.png" alt="n^\mathrm{th}"/> antiderivative of a polynomial and can be used to evaluate definite integrals.  The function <tt class="docutils literal"><span class="pre">poly1d</span></tt> essentially does the same thing as <tt class="docutils literal"><span class="pre">polyval</span></tt> that we encountered in the section <a class="reference internal" href="#specfunc"><em>Special functions</em></a>, but with a different syntax.  Suppose we want to make the polynomial function <img class="math" src="../_images/math/1a0530fa410bf433d7e63640496ceb309230ae8e.png" alt="p(x) = 2x^2 + 5x +1"/>.  Then we write</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [12]: </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="gp">In [13]: </span><span class="n">p</span>
<span class="gr">Out[13]: </span><span class="n">poly1d</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The polynomial <img class="math" src="../_images/math/1a0530fa410bf433d7e63640496ceb309230ae8e.png" alt="p(x) = 2x^2 + 5x +1"/> is evaluated using the syntax <tt class="docutils literal"><span class="pre">p(x)</span></tt>.  Below, we evaluate the polynomial at three different values of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [14]: </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="mf">3.5</span><span class="p">)</span>
<span class="gr">Out[14]: </span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mf">43.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Thus <tt class="docutils literal"><span class="pre">polyval</span></tt> allows us to define the function <img class="math" src="../_images/math/1a0530fa410bf433d7e63640496ceb309230ae8e.png" alt="p(x) = 2x^2 + 5x +1"/>.  Now the antiderivative of <img class="math" src="../_images/math/1a0530fa410bf433d7e63640496ceb309230ae8e.png" alt="p(x) = 2x^2 + 5x +1"/> is <img class="math" src="../_images/math/554fd34cdb264ebf7d81f371438e2cda21a2c0ec.png" alt="P(x) = \frac{2}{3}x^3 + \frac{5}{2}x^2 +x+C"/> where <img class="math" src="../_images/math/2bcc65482aa8e15cd4c9e9f2542451fb4e971a91.png" alt="C"/> is the integration constant.  The NumPy function <tt class="docutils literal"><span class="pre">polyint</span></tt>, which takes the <img class="math" src="../_images/math/1a3679aec3dfb0f6adda3d47ea8364d642a9e903.png" alt="n^\mathrm{th}"/> antiderivative of a polynomial, works as follows</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [15]: </span><span class="n">P</span> <span class="o">=</span> <span class="n">polyint</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">P</span>
<span class="gr">Out[16]: </span><span class="n">poly1d</span><span class="p">([</span> <span class="mf">0.66666667</span><span class="p">,</span>  <span class="mf">2.5</span>     <span class="p">,</span>  <span class="mf">1.</span>      <span class="p">,</span>  <span class="mf">0.</span>      <span class="p">])</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">polyint</span></tt> has a single input, <tt class="docutils literal"><span class="pre">p</span></tt> is this case, <tt class="docutils literal"><span class="pre">polyint</span></tt> returns the coefficients of the antiderivative with the integration constant set to zero, as <tt class="docutils literal"><span class="pre">Out[16]</span></tt> illustrates.  It is then an easy matter to determine any definite integral of the polynomial <img class="math" src="../_images/math/1a0530fa410bf433d7e63640496ceb309230ae8e.png" alt="p(x) = 2x^2 + 5x +1"/> since</p>
<div class="math">
<p><img src="../_images/math/1689072f19978acabc35f7f56eb2570f925fdc0b.png" alt="q \equiv \int_a^b p(x)\, dx = P(b) - P(a) \;."/></p>
</div><p>For example, if <img class="math" src="../_images/math/e417218e5ef6cef6ca7a87991eae44462ba6a101.png" alt="a=1"/> and <img class="math" src="../_images/math/1d2aab11870ff29e19bcd54472e7c12087b7e5c1.png" alt="b=5"/>,</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [17]: </span><span class="n">q</span><span class="o">=</span><span class="n">P</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">-</span><span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="gp">In [18]: </span><span class="n">q</span>
<span class="gr">Out[18]: </span><span class="mf">146.66666666666666</span>
</pre></div>
</div>
<p>or</p>
<div class="math">
<p><img src="../_images/math/f04fbe8d877d4b6ad0bfc44163d137b550f462fa.png" alt="\int_1^5 \left(2x^2 + 5x +1\right)\, dx = 146\tfrac{2}{3} \;."/></p>
</div></div>
</div>
<div class="section" id="double-integrals">
<span id="index-4"></span><h3>9.2.2. Double integrals<a class="headerlink" href="#double-integrals" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">scipy.integrate</span></tt> function <tt class="docutils literal"><span class="pre">dblquad</span></tt> can be used to numerically evaluate double integrals of the form</p>
<div class="math">
<p><img src="../_images/math/e03127b5a9e1875d2a7a890533468d5f2eec6378.png" alt="\int_{y=a}^{y=b} dy \int_{x=g(y)}^{x=h(y)} dx\,f(x,y)"/></p>
</div><p>The general form of <tt class="docutils literal"><span class="pre">dblquad</span></tt> is</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="go">scipy.integrate.dblquad(func, a, b, gfun, hfun)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">func</span></tt> if the name of the function to be integrated, <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are the lower and upper limits of the <tt class="docutils literal"><span class="pre">x</span></tt> variable, respectively, and <tt class="docutils literal"><span class="pre">gfun</span></tt> and <tt class="docutils literal"><span class="pre">hfun</span></tt> are the <em>names</em> of the functions that define the lower and upper limits of the <tt class="docutils literal"><span class="pre">y</span></tt> variable.</p>
<p>As an example, let&#8217;s perform the double integral</p>
<div class="math">
<p><img src="../_images/math/8188b9741892a387cb03e75a2d05dc712b539290.png" alt="\int_0^{1/2} dy \int_0^{\sqrt{1-4y^2}} 16xy\, dx"/></p>
</div><p>We define the functions <cite>f</cite>, <cite>g</cite>, and <cite>h</cite>, using lambda expressions.  Note that even if <cite>g</cite>, and <cite>h</cite> are constants, as they may be in many cases, they must be defined as functions, as we have done here for the lower limit.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [19]: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="mi">16</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span>

<span class="gp">In [20]: </span><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">0</span>

<span class="gp">In [21]: </span><span class="n">h</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span> <span class="p">:</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [22]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">dblquad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="gr">Out[22]: </span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">5.551115123125783e-15</span><span class="p">)</span>
</pre></div>
</div>
<p>Once again, there are two outputs: the first is the value of the integral and the second is its absolute uncertainty.</p>
<p>Of course, the lower limit can also be a function of <img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/>, as we demonstrate here by performing the integral</p>
<div class="math">
<p><img src="../_images/math/e70ac165b37bbdb06be054cef7adfeccb7e6a509.png" alt="\int_0^{1/2} dy \int_{1-2y}^{\sqrt{1-4y^2}} 16xy\, dx"/></p>
</div><p>The code for this is given by</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [23]: </span><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span> <span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span>

<span class="gp">In [24]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">dblquad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="gr">Out[24]: </span><span class="p">(</span><span class="mf">0.33333333333333326</span><span class="p">,</span> <span class="mf">3.700743415417188e-15</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="other-integration-routines">
<h4>9.2.2.1. Other integration routines<a class="headerlink" href="#other-integration-routines" title="Permalink to this headline">¶</a></h4>
<p>In addition to the routines described above, <tt class="docutils literal"><span class="pre">scipy.integrate</span></tt> has a number of other integration routines, including <tt class="docutils literal"><span class="pre">nquad</span></tt>, which performs <img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>-fold multiple integration, as well as other routines that implement other integration algorithms.  You will find, however, that <tt class="docutils literal"><span class="pre">quad</span></tt> and <tt class="docutils literal"><span class="pre">dblquad</span></tt> meet most of your needs for numerical integration.</p>
</div>
</div>
</div>
<div class="section" id="solving-odes">
<span id="index-5"></span><h2>9.3. Solving ODEs<a class="headerlink" href="#solving-odes" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">scipy.integrate</span></tt> library has two powerful powerful routines, <tt class="docutils literal"><span class="pre">ode</span></tt> and <tt class="docutils literal"><span class="pre">odeint</span></tt>, for numerically solving systems of coupled first order ordinary differential equations (ODEs).  While <tt class="docutils literal"><span class="pre">ode</span></tt> is more versatile, <tt class="docutils literal"><span class="pre">odeint</span></tt> (ODE integrator) has a simpler Python interface works very well for most problems.  It can handle both stiff and non-stiff problems.  Here we provide an introduction to <tt class="docutils literal"><span class="pre">odeint</span></tt>.</p>
<p>A typical problem is to solve a second or higher order ODE for a given set of initial conditions.  Here we illustrate using <tt class="docutils literal"><span class="pre">odeint</span></tt> to solve the equation for a driven damped pendulum.  The equation of motion for the angle <img class="math" src="../_images/math/a9cfbeb8ebee1f365919e147a79e242dcb67ee5d.png" alt="\theta"/> that the pendulum makes with the vertical is given by</p>
<div class="math">
<p><img src="../_images/math/87bf1cfa461f26fa789f5648a13dc79a926f53b4.png" alt="\frac{d^2\theta}{dt^2} = -\frac{1}{Q} \frac{d\theta}{dt} +
                          \sin\theta + d \cos\Omega t"/></p>
</div><p>where <img class="math" src="../_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> is time, <img class="math" src="../_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is the quality factor, <img class="math" src="../_images/math/425d86ba2f2979d75b7535c2bcf92c33ed6b285a.png" alt="d"/> is the forcing amplitude, and <img class="math" src="../_images/math/b39932b8cbb311eeee9815738f6be3757737b2ff.png" alt="\Omega"/> is the driving frequency of the forcing.  Reduced variables have been used such that the natural (angular) frequency of oscillation is 1.  The ODE is nonlinear owing to the <img class="math" src="../_images/math/bfaae4e626048c604e91954b8bcf2e89e3c93cf0.png" alt="\sin\theta"/> term.  Of course, it&#8217;s precisely because there are no general methods for solving nonlinear ODEs that one employs numerical techniques, so it seems appropriate that we illustrate the method with a nonlinear ODE.</p>
<p>The first step is always to transform any <img class="math" src="../_images/math/1a3679aec3dfb0f6adda3d47ea8364d642a9e903.png" alt="n^\mathrm{th}"/>-order ODE into a system of <img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> first order ODEs of the form:</p>
<div class="math">
<p><img src="../_images/math/4c3c9d4deddbeaa92858e677bd01aac0d3122ab2.png" alt="\frac{dy_1}{dt} &amp;= f_1(t, y_1, ..., y_n) \\
\frac{dy_2}{dt} &amp;= f_2(t, y_1, ..., y_n) \\
    \vdots\quad &amp;= \quad\vdots \\
\frac{dy_n}{dt} &amp;= f_n(t, y_1, ..., y_n) \;."/></p>
</div><p>We also need <img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> initial conditions, one for each variable <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/>.  Here we have a second order ODE so we will have two coupled ODEs and two initial conditions.</p>
<p>We start by transforming our second order ODE into two coupled first order ODEs.  The transformation is easily accomplished by defining a new variable <img class="math" src="../_images/math/a82a3b8857028941a4375274b13c2bf37d328832.png" alt="\omega \equiv d\theta/dt"/>.  With this definition, we can rewrite our second order ODE as two coupled first order ODEs:</p>
<div class="math">
<p><img src="../_images/math/c39547ea84078f6fa85674a066c33ce0ed72e219.png" alt="\frac{d\theta}{dt} &amp;= \omega \\
\frac{d\omega}{dt} &amp;= -\frac{1}{Q}\,\omega + \sin\theta
                      + d \cos\Omega t \;."/></p>
</div><p>In this case the functions on the right hand side of the equations are</p>
<div class="math">
<p><img src="../_images/math/be5e9ef0971302a758223f43b5673f39c5c7125b.png" alt="f_1(t, \theta, \omega) &amp;= \omega \\
f_2(t, \theta, \omega) &amp;= -\frac{1}{Q}\,\omega + \sin\theta
                          + d \cos\Omega t \;."/></p>
</div><p>Note that there are no explicit derivatives on the right hand side of the functions <img class="math" src="../_images/math/f3e8f82a52bdd47c816d880bdbe685ecfc88160b.png" alt="f_i"/>; they are all functions of <img class="math" src="../_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> and the various <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/>, in this case <img class="math" src="../_images/math/a9cfbeb8ebee1f365919e147a79e242dcb67ee5d.png" alt="\theta"/> and <img class="math" src="../_images/math/c7415c6919c2eb17b1ea36f0243079b59825ee89.png" alt="\omega"/>.</p>
<p>The initial conditions specify the values of <img class="math" src="../_images/math/a9cfbeb8ebee1f365919e147a79e242dcb67ee5d.png" alt="\theta"/> and <img class="math" src="../_images/math/c7415c6919c2eb17b1ea36f0243079b59825ee89.png" alt="\omega"/> at <img class="math" src="../_images/math/4e2677b4edfbb85a135b7807d780a44ffa83f052.png" alt="t=0"/>.</p>
<p>SciPy&#8217;s ODE solver <tt class="docutils literal"><span class="pre">scipy.integrate.odeint</span></tt> has three required arguments and many optional keyword arguments, of which we only need one, <tt class="docutils literal"><span class="pre">args</span></tt>, for this example.  So in this case, <tt class="docutils literal"><span class="pre">odeint</span></tt> has the form</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="go">odeint(func, y0, t, args=())</span>
</pre></div>
</div>
<p>The first argument <tt class="docutils literal"><span class="pre">func</span></tt> is the name of a Python function that returns a list of values of the <img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> functions <img class="math" src="../_images/math/a2db54fc3bc40c34da3b08b2104b6fd200ec54e6.png" alt="f_i(t, y_1, ..., y_n)"/> at a given time <img class="math" src="../_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>.  The second argument <tt class="docutils literal"><span class="pre">y0</span></tt> is an array (or list) of the values of the initial conditions of <img class="math" src="../_images/math/69c92badf76e044bc2cb165cca376fb05c2bd704.png" alt="y_1, ..., y_n)"/>.  The third argument is the array of times at which you want <tt class="docutils literal"><span class="pre">odeint</span></tt> to return the values of <img class="math" src="../_images/math/69c92badf76e044bc2cb165cca376fb05c2bd704.png" alt="y_1, ..., y_n)"/>.  The keyword argument <tt class="docutils literal"><span class="pre">args</span></tt> is a tuple that is used to pass parameters (besides <tt class="docutils literal"><span class="pre">y0</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt>) that are needed to evaluate <tt class="docutils literal"><span class="pre">func</span></tt>.  Our example should make all of this clear.</p>
<p>After having written the <img class="math" src="../_images/math/1a3679aec3dfb0f6adda3d47ea8364d642a9e903.png" alt="n^\mathrm{th}"/>-order ODE as a system of <img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> first-order ODEs, the next task is to write the function <tt class="docutils literal"><span class="pre">func</span></tt>.  The function <tt class="docutils literal"><span class="pre">func</span></tt> should have three arguments: (1) the list (or array) of current <tt class="docutils literal"><span class="pre">y</span></tt> values, the current time <tt class="docutils literal"><span class="pre">t</span></tt>, and a list of any other parameters <tt class="docutils literal"><span class="pre">params</span></tt> needed to evaluate <tt class="docutils literal"><span class="pre">func</span></tt>.  The function <tt class="docutils literal"><span class="pre">func</span></tt> returns the values of the derivatives <img class="math" src="../_images/math/eb25b5047922c9964009ebb1ef8b5b186313e63d.png" alt="dy_i/dt = f_i(t, y_1, ..., y_n)"/> in a list (or array).  Lines 5-11 illustrate how to write <tt class="docutils literal"><span class="pre">func</span></tt> for our example of a driven damped pendulum.  Here we name the function simply <tt class="docutils literal"><span class="pre">f</span></tt>, which is the name that appears in the call to <tt class="docutils literal"><span class="pre">odeint</span></tt> in line 33 below.</p>
<p>The only other tasks remaining are to define the parameters needed in the function, bundling them into a list (see line 22 below),  and to define the initial conditions, and bundling them into another list (see line 25 below).  After defining the time array in lines 28-30, the only remaining task is to call <tt class="docutils literal"><span class="pre">odeint</span></tt> with the appropriate arguments and a variable, <tt class="docutils literal"><span class="pre">psoln</span></tt> in this case to store output.  The output <tt class="docutils literal"><span class="pre">psoln</span></tt> is an <img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> element array where each element is itself an array corresponding the the values of <img class="math" src="../_images/math/410a65f64e2a609a2a7f544ed72f0982b719807a.png" alt="y_i"/> for each time in the time <tt class="docutils literal"><span class="pre">t</span></tt> array that was an argument of <tt class="docutils literal"><span class="pre">odeint</span></tt>.  For this example, the first element <tt class="docutils literal"><span class="pre">psoln[:,0]</span></tt> is the <img class="math" src="../_images/math/f7e73389b494d356293b5ad9e3601a3a61609e96.png" alt="y_0"/> or <tt class="docutils literal"><span class="pre">theta</span></tt> array, and the second element <tt class="docutils literal"><span class="pre">psoln[:,1]</span></tt> is the <img class="math" src="../_images/math/f30c7e391f4cef1d7b14050b5916c857c0979cb5.png" alt="y_1"/> or <tt class="docutils literal"><span class="pre">omega</span></tt> array.  The remainder of the code simply plots out the results in different formats.  The resulting plots are shown in the figure <a class="reference internal" href="#fig-odepend"><em>Pendulum trajectory</em></a> after the code.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">odeint</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">theta</span><span class="p">,</span> <span class="n">omega</span> <span class="o">=</span> <span class="n">y</span>      <span class="c"># unpack current values of y</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">Omega</span> <span class="o">=</span> <span class="n">params</span>  <span class="c"># unpack parameters</span>
    <span class="n">derivs</span> <span class="o">=</span> <span class="p">[</span><span class="n">omega</span><span class="p">,</span>      <span class="c"># list of dy/dt=f functions</span>
             <span class="o">-</span><span class="n">omega</span><span class="o">/</span><span class="n">Q</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Omega</span><span class="o">*</span><span class="n">t</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">derivs</span>

<span class="c"># Parameters</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mf">2.0</span>          <span class="c"># quality factor (inverse damping)</span>
<span class="n">d</span> <span class="o">=</span> <span class="mf">1.5</span>          <span class="c"># forcing amplitude</span>
<span class="n">Omega</span> <span class="o">=</span> <span class="mf">0.65</span>     <span class="c"># drive frequency</span>

<span class="c"># Initial values</span>
<span class="n">theta0</span> <span class="o">=</span> <span class="mf">0.0</span>     <span class="c"># initial angular displacement</span>
<span class="n">omega0</span> <span class="o">=</span> <span class="mf">0.0</span>     <span class="c"># initial angular velocity</span>

<span class="c"># Bundle parameters for ODE solver</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">Omega</span><span class="p">]</span>

<span class="c"># Bundle initial conditions for ODE solver</span>
<span class="n">y0</span> <span class="o">=</span> <span class="p">[</span><span class="n">theta0</span><span class="p">,</span> <span class="n">omega0</span><span class="p">]</span>

<span class="c"># Make time array for solution</span>
<span class="n">tStop</span> <span class="o">=</span> <span class="mf">200.</span>
<span class="n">tInc</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">tStop</span><span class="p">,</span> <span class="n">tInc</span><span class="p">)</span>

<span class="c"># Call the ODE solver</span>
<span class="n">psoln</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">params</span><span class="p">,))</span>

<span class="c"># Plot results</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="c"># Plot theta as a function of time</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">311</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psoln</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;theta&#39;</span><span class="p">)</span>

<span class="c"># Plot omega as a function of time</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">312</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psoln</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;omega&#39;</span><span class="p">)</span>

<span class="c"># Plot omega vs theta</span>
<span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">313</span><span class="p">)</span>
<span class="n">twopi</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">psoln</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="n">twopi</span><span class="p">,</span> <span class="n">psoln</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;theta&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;omega&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">twopi</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<div class="figure align-center" id="fig-odepend">
<a class="reference internal image-reference" href="../_images/odePend.png"><img alt="../_images/odePend.png" src="../_images/odePend.png" style="width: 640.0px; height: 640.0px;" /></a>
<p class="caption">Pendulum trajectory</p>
</div>
<p>The plots above reveal that for the particular set of input parameters chosen, <tt class="docutils literal"><span class="pre">Q</span> <span class="pre">=</span> <span class="pre">2.0</span></tt>, <tt class="docutils literal"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">1.5</span></tt>, and <tt class="docutils literal"><span class="pre">Omega</span> <span class="pre">=</span> <span class="pre">0.65</span></tt>, the pendulum trajectories are chaotic.  Weaker forcing (smaller <img class="math" src="../_images/math/425d86ba2f2979d75b7535c2bcf92c33ed6b285a.png" alt="d"/>) leads to what is perhaps the more familiar behavior of sinusoidal oscillations with a fixed frequency which, at long times, is equal to the driving frequency.</p>
</div>
<div class="section" id="discrete-fast-fourier-transforms">
<span id="index-6"></span><h2>9.4. Discrete (fast) Fourier transforms<a class="headerlink" href="#discrete-fast-fourier-transforms" title="Permalink to this headline">¶</a></h2>
<p>The SciPy library has a number of routines for performing discrete Fourier transforms.  Before delving into them, we provide a brief review of Fourier transforms and discrete Fourier transforms.</p>
<div class="section" id="continuous-and-discrete-fourier-transforms">
<h3>9.4.1. Continuous and discrete Fourier transforms<a class="headerlink" href="#continuous-and-discrete-fourier-transforms" title="Permalink to this headline">¶</a></h3>
<p>The Fourier transform of a function <img class="math" src="../_images/math/0491e54e8cdc5a9f8e5dcdbc42d4d8600f669bab.png" alt="g(t)"/> is given by</p>
<div class="math" id="equation-eq:FT">
<p><span class="eqno">(1)</span><img src="../_images/math/94ee5e2a23a487c9c54cfcc4979293ad002e0d09.png" alt="G(f) = \int_{-\infty}^\infty g(t)\, e^{-i\, 2\pi f t}\, dt \;,"/></p>
</div><p>where <img class="math" src="../_images/math/0001d02b63ede2fe3219e05a7cd09c82ae6298b6.png" alt="f"/> is the Fourier transform variable; if <img class="math" src="../_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> is time, then <img class="math" src="../_images/math/0001d02b63ede2fe3219e05a7cd09c82ae6298b6.png" alt="f"/> is frequency.  The inverse transform is given by</p>
<div class="math" id="equation-eq:iFT">
<p><span class="eqno">(2)</span><img src="../_images/math/dfcd2c5cbc1aea783ed036185f7b79d8efb68f60.png" alt="g(t) = \int_{-\infty}^\infty G(f)\, e^{i\, 2\pi ft}\, df"/></p>
</div><p>Here we define the Fourier transform in terms of the frequency <img class="math" src="../_images/math/0001d02b63ede2fe3219e05a7cd09c82ae6298b6.png" alt="f"/> rather than the angular frequency <img class="math" src="../_images/math/06f61ef1f38a139ea462551363d15d3baf464b58.png" alt="\omega = 2\pi f"/>.</p>
<p>The conventional Fourier transform is defined for continuous functions, or at least for functions that are dense and thus have an infinite number of data points.  When doing numerical analysis, however, you work with <em>discrete</em> data sets, that is, data sets defined for a finite number of points.  The discrete Fourier transform (DFT) is defined for a function <img class="math" src="../_images/math/4512a4371ffba649d03164449dbac672aa46f99f.png" alt="g_n"/> consisting of a set of <img class="math" src="../_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/> discrete data points.  Those <img class="math" src="../_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/> data points must be defined at <em>equally-spaced</em> times <img class="math" src="../_images/math/647a754341ebaeb8893dbd6842064c3d0af4b4df.png" alt="t_n=n\Delta t"/> where <img class="math" src="../_images/math/5b4271afe7fc7c0ee84172e0ad19b82caf450c00.png" alt="\Delta t"/> is the time between successive data points and <img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> runs from 0 to <img class="math" src="../_images/math/19f9ae9a7d789d9a8e661b478df966192038b540.png" alt="N-1"/>.  The discrete Fourier transform (DFT) of <img class="math" src="../_images/math/4512a4371ffba649d03164449dbac672aa46f99f.png" alt="g_n"/> is defined as</p>
<div class="math" id="equation-eq:DFT">
<p><span class="eqno">(3)</span><img src="../_images/math/9e37c81313a35fd17203d3344f15d915e3618cf4.png" alt="G_l = \sum_{n=0}^{N-1} g_n\, e^{-i\,(2\pi/N)\,ln}"/></p>
</div><p>where <img class="math" src="../_images/math/d99efde75c84ef402a92cd4497530d2366fb112f.png" alt="l"/> runs from 0 to <img class="math" src="../_images/math/19f9ae9a7d789d9a8e661b478df966192038b540.png" alt="N-1"/>.  The inverse discrete Fourier transform (iDFT) is defined as</p>
<div class="math" id="equation-eq:iDFT">
<p><span class="eqno">(4)</span><img src="../_images/math/a3e66562f9a733b0726c9440e9a43468a24f8014.png" alt="g_n = \frac{1}{N} \sum_{l=0}^{N-1} G_l\, e^{i\,(2\pi/N)\,ln} \;."/></p>
</div><p>The DFT is usually implemented on computers using the well-known Fast Fourier Transform (FFT) algorithm, generally credited to Cooley and Tukey who developed it at AT&amp;T Bell Laboratories during the 1960s.  But their algorithm is essentially one of many independent rediscoveries of the basic algorithm dating back to Gauss who described it as early as 1805.</p>
</div>
<div class="section" id="the-scipy-fft-library">
<h3>9.4.2. The SciPy FFT library<a class="headerlink" href="#the-scipy-fft-library" title="Permalink to this headline">¶</a></h3>
<p>The SciPy library <tt class="docutils literal"><span class="pre">scipy.fftpack</span></tt> has routines that implement a souped-up version of the FFT algorithm along with many ancillary routines that support working with DFTs.  The basic FFT routine in <tt class="docutils literal"><span class="pre">scipy.fftpack</span></tt> is appropriately named <tt class="docutils literal"><span class="pre">fft</span></tt>.  The program below illustrates its use, along with the plots that follow.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">fftpack</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">width</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>   <span class="c"># linearly space time array</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c"># increment between times in time array</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>   <span class="c"># FFT of g</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span> <span class="c"># frequenies f[i] of g[i]</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>     <span class="c"># shift frequencies from min to max</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>     <span class="c"># shift G order to coorespond to f</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">frameon</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;g(t)&#39;</span><span class="p">)</span>

<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;dodgerblue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;real part&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;coral&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;imaginary part&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;G(f)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center" id="fig-fftsimple">
<a class="reference internal image-reference" href="../_images/fftSimple.png"><img alt="Function :math:`g(t)` and its DFT :math:`G(f)`." src="../_images/fftSimple.png" style="width: 560.0px; height: 420.8px;" /></a>
<p class="caption">Function <img class="math" src="../_images/math/0491e54e8cdc5a9f8e5dcdbc42d4d8600f669bab.png" alt="g(t)"/> and its DFT <img class="math" src="../_images/math/1727c8eae6a42fd0aac262912c6dfe9189c21a74.png" alt="G(f)"/>.</p>
</div>
<p>The DFT has real and imaginary parts, both of which are plotted in the figure.</p>
<p>The <tt class="docutils literal"><span class="pre">fft</span></tt> function returns the <img class="math" src="../_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/> Fourier components of <img class="math" src="../_images/math/1e052268a119482119544c14cb336fdfe63e0f1d.png" alt="G_n"/> starting with the zero-frequency component <img class="math" src="../_images/math/787db56b15092dd4d749cdf10fe3d67ddd0fc985.png" alt="G_0"/> and progressing to the maximum positive frequency component <img class="math" src="../_images/math/5b7d7803d4d98d72bc3fe019b8c9f95b331508fc.png" alt="G_{(N/2)-1}"/> (or <img class="math" src="../_images/math/7397f45f3a0a4abf8f2f2e42e5b30b0092f3fbc1.png" alt="G_{(N-1)/2}"/> if <img class="math" src="../_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/> is odd).  From there, <tt class="docutils literal"><span class="pre">fft</span></tt> returns the maximum <em>negative</em> component <img class="math" src="../_images/math/4951562bb6df70a2cd64f02da03aae14cf864c37.png" alt="G_{N/2}"/>  (or <img class="math" src="../_images/math/7397f45f3a0a4abf8f2f2e42e5b30b0092f3fbc1.png" alt="G_{(N-1)/2}"/> if <img class="math" src="../_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/> is odd) and continues upward in frequency until it reaches the minimum negative frequency component <img class="math" src="../_images/math/5006646a48704bd78b024a3d8f1d72fda3c6d074.png" alt="G_{N-1}"/>.  This is the standard way that DFTs are ordered by most numerical DFT packages.  The <tt class="docutils literal"><span class="pre">scipy.fftpack</span></tt> function <tt class="docutils literal"><span class="pre">fftfreq</span></tt> creates the array of frequencies in this non-intuitive order such that <tt class="docutils literal"><span class="pre">f[n]</span></tt> in the above routine is the correct frequency for the Fourier component <tt class="docutils literal"><span class="pre">G[n]</span></tt>.  The arguments of <tt class="docutils literal"><span class="pre">fftfreq</span></tt> are the size of the the orignal array <tt class="docutils literal"><span class="pre">g</span></tt> and the keyword argument <tt class="docutils literal"><span class="pre">d</span></tt> that is the spacing between the (equally spaced) elements of the time array (<tt class="docutils literal"><span class="pre">d=1</span></tt> if left unspecified).  The package <tt class="docutils literal"><span class="pre">scipy.fftpack</span></tt> provides the convenience function <tt class="docutils literal"><span class="pre">fftshift</span></tt> that reorders the frequency array so that the zero-frequency occurs at the middle of the array, that is, so the frequencies proceed monotonically from smallest (most negative) to largest (most positive).  Applying <tt class="docutils literal"><span class="pre">fftshift</span></tt> to both <tt class="docutils literal"><span class="pre">f</span></tt> and <tt class="docutils literal"><span class="pre">G</span></tt> puts the frequencies <tt class="docutils literal"><span class="pre">f</span></tt> in ascending order and shifts <tt class="docutils literal"><span class="pre">G</span></tt> so that the frequency of <tt class="docutils literal"><span class="pre">G[n]</span></tt> is given by the shifted <tt class="docutils literal"><span class="pre">f[n]</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">scipy.fftpack</span></tt> module also contains routines for performing 2-dimensional and <img class="math" src="../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>-dimensional DFTs, named <tt class="docutils literal"><span class="pre">fft2</span></tt> and <tt class="docutils literal"><span class="pre">fftn</span></tt>, respectively, using the FFT algorithm.</p>
<p>As for most FFT routines, the <tt class="docutils literal"><span class="pre">scipy.fftpack</span></tt> FFT routines are most efficient if <img class="math" src="../_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/> is a power of 2.  Nevertheless, the FFT routines are able to handle data sets where <img class="math" src="../_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/> is not a power of 2.</p>
<p><tt class="docutils literal"><span class="pre">scipy.fftpack</span></tt> also supplies an inverse DFT function <tt class="docutils literal"><span class="pre">ifft</span></tt>.  It is written to act on the <em>unshifted</em> FFT so take care!  Note also that <tt class="docutils literal"><span class="pre">ifft</span></tt> returns a <em>complex</em> array.  Because of machine roundoff error, the imaginary part of the function returned by <tt class="docutils literal"><span class="pre">ifft</span></tt> will, in general, be very near zero but not exactly zero even when the original function is a purely real function.</p>
</div>
</div>
<div class="section" id="linear-algebra">
<span id="index-7"></span><h2>9.5. Linear algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h2>
<p>Python&#8217;s mathematical libraries, NumPy and SciPy, have extensive tools for numerically solving problems in linear algebra.  Here we focus on two problems that arise commonly in scientific and engineering settings: (1) solving a system of linear equations and (2) eigenvalue problems.  In addition, we also show how to perform a number of other basic computations, such as finding the determinant of a matrix, matrix inversion, and <img class="math" src="../_images/math/aaf00e3adaeb5a75dcbe3b7849e67996aa6eae2a.png" alt="LU"/> decomposition.  The SciPy package for linear algebra is called <tt class="docutils literal"><span class="pre">scipy.linalg</span></tt>.</p>
<div class="section" id="basic-computations-in-linear-algebra">
<h3>9.5.1. Basic computations in linear algebra<a class="headerlink" href="#basic-computations-in-linear-algebra" title="Permalink to this headline">¶</a></h3>
<p>SciPy has a number of routines for performing basic operations with matrices.  The determinant of a matrix is computed using the <tt class="docutils literal"><span class="pre">scipy.linalg.det</span></tt> function:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="gp">In [2]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">In [3]: </span><span class="n">a</span>
<span class="gr">Out[4]: </span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
<span class="go">               [ 4,  5]])</span>

<span class="gp">In [5]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gr">Out[5]: </span><span class="o">-</span><span class="mf">22.0</span>
</pre></div>
</div>
<p>The inverse of a matrix is computed using the <tt class="docutils literal"><span class="pre">scipy.linalg.inv</span></tt> function, while the product of two matrices  is calculated using the NumPy <tt class="docutils literal"><span class="pre">dot</span></tt> function:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [6]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">b</span>
<span class="gr">Out[6]: </span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.22727273</span><span class="p">,</span>  <span class="mf">0.13636364</span><span class="p">],</span>
<span class="go">               [ 0.18181818,  0.09090909]])</span>

<span class="gp">In [7]: </span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="gr">Out[7]: </span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="go">               [ 0.,  1.]])</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-systems-of-linear-equations">
<span id="index-8"></span><h3>9.5.2. Solving systems of linear equations<a class="headerlink" href="#solving-systems-of-linear-equations" title="Permalink to this headline">¶</a></h3>
<p>Solving systems of equations is nearly as simple as constructing a coefficient matrix and a column vector.  Suppose you have the following system of linear equations to solve:</p>
<div class="math">
<p><img src="../_images/math/2464025d7a42ba4ac55b45bd3e17d257f21c8644.png" alt="2x_1 + 4x_2 + 6x_3 &amp;= 4\\
 x_1 - 3x_2 - 9x_3 &amp;= -11\\
8x_1 + 5x_2 - 7x_3 &amp;= 1\\"/></p>
</div><p>The first task is to recast this set of equations as a matrix equation of the form <img class="math" src="../_images/math/007268c685628a9b5e25763cdf7104c8bc1dd980.png" alt="\mathsf{A}\, \mathbf{x} = \mathbf{b}"/>.  In this  case, we have:</p>
<div class="math">
<p><img src="../_images/math/b16ec1542f32ab9a7aabf0ef55ad7162a7af173f.png" alt="\mathsf{A} = \left(\begin{array}{ccc}2 &amp;  4 &amp;  6 \\
                                     1 &amp; -3 &amp; -9 \\
                                     8 &amp;  5 &amp; -7 \end{array}\right)
                                     \;,\quad
\mathbf{x} = \left(\begin{array}{c}x_1 \\x_2 \\x_3\end{array}\right)
                                     \;,\quad
\mathbf{b} = \left(\begin{array}{c}4 \\-11 \\1\end{array}\right) \;."/></p>
</div><p>Next we construct the array <img class="math" src="../_images/math/cdef297ba2f30300e8fbea67c045cfbe0cc062be.png" alt="\mathsf{A}"/> and vector <img class="math" src="../_images/math/dd6a0c79ee7e76c8e6f1310a5d171d5b3848b685.png" alt="\mathbf{b}"/> as NumPy arrays:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [8]: </span><span class="n">A</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">]])</span>
<span class="gp">In [9]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Finally we use the SciPy function <tt class="docutils literal"><span class="pre">scipy.linalg.solve</span></tt> to find <img class="math" src="../_images/math/b31b1ea8e4fe3f618dedfb0e2d8c69a3df7a391d.png" alt="x_1"/>, <img class="math" src="../_images/math/272c62c44455c90173267b1bafdf7ecebd6bc316.png" alt="x_2"/>, and <img class="math" src="../_images/math/5ea15a7136b3743ca4eebc744fa85be7b81a0c4d.png" alt="x_3"/>.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [10]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="gr">Out[10]: </span><span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="mf">8.91304348</span><span class="p">,</span>  <span class="mf">10.2173913</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">3.17391304</span><span class="p">])</span>
</pre></div>
</div>
<p>which gives the results: <img class="math" src="../_images/math/abf532b0fb0eb8583244f503b8c1848839ac0cac.png" alt="x_1=-8.91304348"/>, <img class="math" src="../_images/math/38fb49460f92058336de5a4218cc1fd4965704f8.png" alt="x_2= 10.2173913"/>, and <img class="math" src="../_images/math/c4647bed3969a1e15d1a5408abadbd18a0987463.png" alt="x_3= -3.17391304"/>.  Of course, you can get the same answer by noting that <img class="math" src="../_images/math/fc9796859c33c57f51c3b163a2acbed7a9d0ad41.png" alt="\mathbf{x}=\mathsf{A}^{-1}\mathbf{b}"/>.  Following this approach, we can use the <cite>scipy.linalg.inv</cite> introduced in the previous section:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="go">Ainv = scipy.linalg.inv(A)</span>

<span class="gp">In [10]: </span><span class="n">dot</span><span class="p">(</span><span class="n">Ainv</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gr">Out[10]: </span><span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="mf">8.91304348</span><span class="p">,</span>  <span class="mf">10.2173913</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">3.17391304</span><span class="p">])</span>
</pre></div>
</div>
<p>which is the same answer we obtained using <tt class="docutils literal"><span class="pre">scipy.linalg.solve</span></tt>.  Using <tt class="docutils literal"><span class="pre">scipy.linalg.solve</span></tt> is numerically more stable and a faster than using <img class="math" src="../_images/math/fc9796859c33c57f51c3b163a2acbed7a9d0ad41.png" alt="\mathbf{x}=\mathsf{A}^{-1}\mathbf{b}"/>, so it is the preferred method for solving systems of equations.</p>
<p>You might wonder what happens if the system of equations are not all linearly independent.  For example if the matrix <img class="math" src="../_images/math/cdef297ba2f30300e8fbea67c045cfbe0cc062be.png" alt="\mathsf{A}"/> is given by</p>
<div class="math">
<p><img src="../_images/math/99e88615d0f3d8f3b27fab421dfa3415ff7138c9.png" alt="\mathsf{A} = \left(\begin{array}{ccc}2 &amp;  4 &amp;  6 \\
                                     1 &amp; -3 &amp; -9 \\
                                     1 &amp;  2 &amp;  3 \end{array}\right)"/></p>
</div><p>where the third row is a multiple of the first row.  Let&#8217;s try it out and see what happens.  First we change the bottom row of the matrix <img class="math" src="../_images/math/cdef297ba2f30300e8fbea67c045cfbe0cc062be.png" alt="\mathsf{A}"/> and then try to solve the system as we did before.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [11]: </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="gp">In [12]: </span><span class="n">A</span>
<span class="gr">Out[12]: </span><span class="n">array</span><span class="p">([[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
<span class="go">                [ 1, -3, -9],</span>
<span class="go">                [ 1,  2,  3]])</span>

<span class="gp">In [13]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">LinAlgError: Singular matrix</span>

<span class="gp">In [14]: </span><span class="n">Ainv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">LinAlgError: Singular matrix</span>
</pre></div>
</div>
<p>Whether we use <tt class="docutils literal"><span class="pre">scipy.linalg.solve</span></tt> or <tt class="docutils literal"><span class="pre">scipy.linalg.inv</span></tt>, SciPy raises an error because the matrix is singular.</p>
</div>
<div class="section" id="eigenvalue-problems">
<span id="index-9"></span><h3>9.5.3. Eigenvalue problems<a class="headerlink" href="#eigenvalue-problems" title="Permalink to this headline">¶</a></h3>
<p>One of the most common problems in science and engineering is the eigenvalue problem, which in matrix form is written as</p>
<div class="math">
<p><img src="../_images/math/efddf1960470e3fbc30ac728ccc029bf89e2001c.png" alt="\mathsf{A}\mathbf{x} = \lambda \mathbf{x}"/></p>
</div><p>where <img class="math" src="../_images/math/cdef297ba2f30300e8fbea67c045cfbe0cc062be.png" alt="\mathsf{A}"/> is a square matrix, <img class="math" src="../_images/math/46aec6aaff80d183cc0ed35d77ce75c7c9ffd174.png" alt="\mathbf{x}"/> is a column vector, and <img class="math" src="../_images/math/1ab0134b6e0837594649c75a2ed83cfd85a2d03d.png" alt="\lambda"/> is a scalar (number).   Given the matrix <img class="math" src="../_images/math/cdef297ba2f30300e8fbea67c045cfbe0cc062be.png" alt="\mathsf{A}"/>, the problem is to find the set of eigenvectors <img class="math" src="../_images/math/46aec6aaff80d183cc0ed35d77ce75c7c9ffd174.png" alt="\mathbf{x}"/> and their corresponding eigenvalues <img class="math" src="../_images/math/1ab0134b6e0837594649c75a2ed83cfd85a2d03d.png" alt="\lambda"/> that solve this equation.</p>
<p>We can solve eigenvalue equations like this using <tt class="docutils literal"><span class="pre">scipy.linalg.eig</span></tt>. the outputs of this function is an array whose entries are the eigenvalues and a matrix whose rows are the eigenvectors.  Let&#8217;s return to the matrix we were using previously and find its eigenvalues and eigenvectors.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="go">A = array([[2, 4, 6],[1, -3, -9],[8, 5, -7]])</span>

<span class="gp">In [15]: </span><span class="n">A</span>
<span class="gr">Out[15]: </span><span class="n">array</span><span class="p">([[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
<span class="go">                [ 1, -3, -9],</span>
<span class="go">                [ 8,  5, -7]])</span>

<span class="gp">In [16]: </span><span class="n">lam</span><span class="p">,</span> <span class="n">evec</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="gp">In [17]: </span><span class="n">lam</span>
<span class="gr">Out[17]: </span><span class="n">array</span><span class="p">([</span> <span class="mf">2.40995356</span><span class="o">+</span><span class="mf">0.j</span><span class="p">,</span> <span class="o">-</span><span class="mf">8.03416016</span><span class="o">+</span><span class="mf">0.j</span><span class="p">,</span>
<span class="go">                -2.37579340+0.j])</span>

<span class="gp">In [18]: </span><span class="n">evec</span>
<span class="gr">Out[18]: </span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.77167559</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.52633654</span><span class="p">,</span>  <span class="mf">0.57513303</span><span class="p">],</span>
<span class="go">                [ 0.50360249,  0.76565448, -0.80920669],</span>
<span class="go">                [-0.38846018,  0.36978786,  0.12002724]])</span>
</pre></div>
</div>
<p>The first eigenvalue and its corresponding eigenvector are given by</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [19]: </span><span class="n">lam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[19]: </span><span class="p">(</span><span class="mf">2.4099535647625494</span><span class="o">+</span><span class="mi">0j</span><span class="p">)</span>

<span class="gp">In [20]: </span><span class="n">evec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[20]: </span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.77167559</span><span class="p">,</span>  <span class="mf">0.50360249</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.38846018</span><span class="p">])</span>
</pre></div>
</div>
<p>We can check that they satisfy the <img class="math" src="../_images/math/35495cc42ba526e3de54768d6443d3c5be828aa0.png" alt="\mathsf{A}\mathbf{x} = \lambda \mathbf{x}:"/></p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [21]: </span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">evec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
<span class="gr">Out[21]: </span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.85970234</span><span class="p">,</span>  <span class="mf">1.21365861</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.93617101</span><span class="p">])</span>

<span class="gp">In [22]: </span><span class="n">lam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">evec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="gr">Out[22]: </span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.85970234</span><span class="o">+</span><span class="mf">0.j</span><span class="p">,</span>  <span class="mf">1.21365861</span><span class="o">+</span><span class="mf">0.j</span><span class="p">,</span>
<span class="go">                -0.93617101+0.j])</span>
</pre></div>
</div>
<p>Thus we see by direct substitution that the left and right sides of <img class="math" src="../_images/math/35495cc42ba526e3de54768d6443d3c5be828aa0.png" alt="\mathsf{A}\mathbf{x} = \lambda \mathbf{x}:"/> are equal.   In general, the eigenvalues can be complex, so their values are reported as complex numbers.</p>
<div class="section" id="generalized-eigenvalue-problem">
<span id="index-10"></span><h4>9.5.3.1. Generalized eigenvalue problem<a class="headerlink" href="#generalized-eigenvalue-problem" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">scipy.linalg.eig</span></tt> function can also solve the <em>generalized</em> eigenvalue problem</p>
<div class="math">
<p><img src="../_images/math/7b7f0cd337c638c0982b96abe9c82f2e19b13d6c.png" alt="\mathsf{A}\mathbf{x} = \lambda \mathsf{B}\mathbf{x}"/></p>
</div><p>where <img class="math" src="../_images/math/623cb4fb31b6a1e37730e54c184784ae87bde9c8.png" alt="\mathsf{B}"/> is a square matrix with the same size as <img class="math" src="../_images/math/cdef297ba2f30300e8fbea67c045cfbe0cc062be.png" alt="\mathsf{A}"/>.  Suppose, for example, that we have</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [22]: </span><span class="n">A</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">]])</span>
<span class="gr">Out[22]: </span><span class="n">B</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</pre></div>
</div>
<p>Then we can solve the generalized eigenvalue problem by entering <img class="math" src="../_images/math/623cb4fb31b6a1e37730e54c184784ae87bde9c8.png" alt="\mathsf{B}"/> as the optional second argument to <tt class="docutils literal"><span class="pre">scipy.linalg.eig</span></tt></p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [23]: </span><span class="n">lam</span><span class="p">,</span> <span class="n">evec</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>The solutions are returned in the same fashion as before, as an array <tt class="docutils literal"><span class="pre">lam</span></tt> whose entries are the eigenvalues and a matrix <tt class="docutils literal"><span class="pre">evac</span></tt> whose rows are the eigenvectors.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [24]: </span><span class="n">lam</span>
<span class="gr">Out[24]: </span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.36087907</span><span class="o">+</span><span class="mf">0.j</span><span class="p">,</span>  <span class="mf">0.83252442</span><span class="o">+</span><span class="mf">0.j</span><span class="p">,</span>
<span class="go">                -0.10099858+0.j])</span>

<span class="gp">In [25]: </span><span class="n">evec</span>
<span class="gr">Out[25]: </span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.0419907</span> <span class="p">,</span> <span class="o">-</span><span class="mf">1.</span>        <span class="p">,</span>  <span class="mf">0.93037493</span><span class="p">],</span>
<span class="go">                [-0.43028153,  0.17751302, -1.        ],</span>
<span class="go">                [ 1.        , -0.29852465,  0.4226201 ]])</span>
</pre></div>
</div>
</div>
<div class="section" id="hermitian-and-banded-matrices">
<span id="index-11"></span><h4>9.5.3.2. Hermitian and banded matrices<a class="headerlink" href="#hermitian-and-banded-matrices" title="Permalink to this headline">¶</a></h4>
<p>SciPy has a specialized routine for solving eigenvalue problems for Hermitian (or real symmetric) matrices.  The routine for hermitian matrices is <tt class="docutils literal"><span class="pre">scipy.linalg.eigh</span></tt>.  It is more efficient (faster and uses less memory) than <tt class="docutils literal"><span class="pre">scipy.linalg.eig</span></tt>.  The basic syntax of the two routines is the same, although some of the <em>optional</em> arguments are different.  Both routines can solve generalized as well as standard eigenvalue problems.</p>
<p>SciPy also has a specialized routine <tt class="docutils literal"><span class="pre">scipy.linalg.eig_banded</span></tt> for solving eigenvalue problems for real symmetric or complex hermitian banded matrices.</p>
</div>
</div>
</div>
<div class="section" id="solving-non-linear-equations">
<span id="sec-findingroots"></span><span id="index-12"></span><h2>9.6. Solving non-linear equations<a class="headerlink" href="#solving-non-linear-equations" title="Permalink to this headline">¶</a></h2>
<p>SciPy has many different routines for numerically solving non-linear equations or systems of non-linear equations.  Here we will introduce only a few of these routines, the ones that are relatively simple and appropriate for the most common types of nonlinear equations.</p>
<div class="section" id="single-equations-of-a-single-variable">
<h3>9.6.1. Single equations of a single variable<a class="headerlink" href="#single-equations-of-a-single-variable" title="Permalink to this headline">¶</a></h3>
<p>Solving a single nonlinear equation is enormously simpler than solving a system of nonlinear equations, so that is where we start.  A word of caution: solving non-linear equations can be a tricky business so it is important that you have a good sense of the behavior of the function you are trying to solve.  The best way to do this is to plot the function over the domain of interest before trying to find the solutions.  This will greatly assist you in finding the solutions you seek and avoiding spurious solutions.</p>
<p>We begin with a concrete example.  Suppose we want to find the solutions to the equation</p>
<div class="math">
<p><img src="../_images/math/13afb85f5f6a618ce6b409e8ad82d4d32194c859.png" alt="\tan x=\sqrt{(8/x)^2-1}"/></p>
</div><p>Plots of <img class="math" src="../_images/math/c85df0bdf7d6d815984ca964f1eca5e3eaa3cee5.png" alt="\tan x"/> and <img class="math" src="../_images/math/508dcbaff709160fc7fcacb49beeb0dfc980777d.png" alt="\sqrt{(8/x)^2-1}"/> <em>vs</em> <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> are shown in the top plot in the figure <a class="reference internal" href="../chap5/chap5_plot.html#fig-subplotdemo"><em>Crossing functions</em></a>, albeit with <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> replaced by <img class="math" src="../_images/math/a9cfbeb8ebee1f365919e147a79e242dcb67ee5d.png" alt="\theta"/>.  The solutions to this equation are those <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> values where the two curves <img class="math" src="../_images/math/c85df0bdf7d6d815984ca964f1eca5e3eaa3cee5.png" alt="\tan x"/> and <img class="math" src="../_images/math/508dcbaff709160fc7fcacb49beeb0dfc980777d.png" alt="\sqrt{(8/x)^2-1}"/> cross each other. The first step towards obtaining a numerical solution is to rewrite the equation to be solved in the form <img class="math" src="../_images/math/3a230438ae4cdcf41cf00fba0e2b5c4eb7507939.png" alt="f(x)=0"/>.  Doing so, the above equation becomes</p>
<div class="math">
<p><img src="../_images/math/97f5c3b5b1196a7de6049456575709cc71ceed1b.png" alt="\tan x - \sqrt{(8/x)^2-1} = 0"/></p>
</div><p>Obviously the two equations above have the same solutions for <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/>.  Parenthetically we mention that the problem of finding the solutions to equations of the form <img class="math" src="../_images/math/3a230438ae4cdcf41cf00fba0e2b5c4eb7507939.png" alt="f(x)=0"/> is often referred to as <em>finding the roots</em> of <img class="math" src="../_images/math/14546c27a7b929642f7840acca5f851c503ea109.png" alt="f(x)"/>.</p>
<p>Next, we plot <img class="math" src="../_images/math/14546c27a7b929642f7840acca5f851c503ea109.png" alt="f(x)"/> over the domain of interest, in this case from <img class="math" src="../_images/math/55ba271999995cac02cf578362df5be030594ed6.png" alt="x=0"/> to 8.  We are only interested in positive solutions and for <img class="math" src="../_images/math/417bc6d7ba87e7fb573e734de4913003692ae3b8.png" alt="x&gt;8"/>, the equation has no real solutions as the argument of the square root becomes negative.  The solutions, the points where <img class="math" src="../_images/math/3a230438ae4cdcf41cf00fba0e2b5c4eb7507939.png" alt="f(x)=0"/> are indicated by green circles; there are three of them. Another notable feature of the function is that it diverges to <img class="math" src="../_images/math/9e0d43547af6ade3b647231a5b32a0ce3cd9bbcf.png" alt="\pm\infty"/> at <img class="math" src="../_images/math/46474daf11185cb90fd88b90a469e31b4d6f9f49.png" alt="x = \{0, \pi/2, 3\pi/2, 5\pi/2\}"/>.</p>
<div class="figure align-center" id="fig-rootdemo">
<a class="reference internal image-reference" href="../_images/rootsBrent.png"><img alt="Roots of a nonlinear function" src="../_images/rootsBrent.png" style="width: 540.0px; height: 360.0px;" /></a>
<p class="caption">Roots of a nonlinear function</p>
</div>
<div class="section" id="brent-method">
<span id="index-13"></span><h4>9.6.1.1. Brent method<a class="headerlink" href="#brent-method" title="Permalink to this headline">¶</a></h4>
<p>One of the workhorses for finding solutions to a single variable nonlinear equation is the method of Brent, discussed in many texts on numerical methods.  SciPy&#8217;s implementation of the Brent algorithm is the function <tt class="docutils literal"><span class="pre">scipy.optimize.brentq(f,</span> <span class="pre">a,</span> <span class="pre">b)</span></tt>, which has three required arguments.  The first <tt class="docutils literal"><span class="pre">f</span></tt> is the name of the user-defined function to be solved.  The next two, <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are the <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> values that bracket the solution you are looking for.  You should choose <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> so that there is only one solutions in the interval between <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>.  Brent&#8217;s method also requires that <tt class="docutils literal"><span class="pre">f(a)</span></tt> and <tt class="docutils literal"><span class="pre">f(b)</span></tt> have opposite signs; an error message is returned if they do not.  Thus to find the three solutions to <img class="math" src="../_images/math/f26671f61f7d9dddedfc342c7ae001c72b47c469.png" alt="\tan x - \sqrt{(8/x)^2-1} = 0"/>, we need to run <tt class="docutils literal"><span class="pre">scipy.optimize.brentq(f,</span> <span class="pre">a,</span> <span class="pre">b)</span></tt> three times using three different values of <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> that bracket each of the three solutions.  The program below illustrates the how to use <tt class="docutils literal"><span class="pre">scipy.optimize.brentq</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">tdl</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mf">8.</span><span class="o">/</span><span class="n">x</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c"># Find true roots</span>

<span class="n">rx1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">tdl</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.49</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">rx2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">tdl</span><span class="p">,</span> <span class="mf">0.51</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">1.49</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">rx3</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">tdl</span><span class="p">,</span> <span class="mf">1.51</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">2.49</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rx1</span><span class="p">,</span> <span class="n">rx2</span><span class="p">,</span> <span class="n">rx3</span><span class="p">])</span>
<span class="n">ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c"># print using a list comprehension</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">True roots:&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;f({0:0.5f}) = {1:0.2e}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tdl</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rx</span><span class="p">))</span>

<span class="c"># Find false roots</span>

<span class="n">rx1f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">tdl</span><span class="p">,</span> <span class="mf">0.49</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.51</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">rx2f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">tdl</span><span class="p">,</span> <span class="mf">1.49</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">1.51</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">rx3f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">tdl</span><span class="p">,</span> <span class="mf">2.49</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">2.51</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">rxf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rx1f</span><span class="p">,</span> <span class="n">rx2f</span><span class="p">,</span> <span class="n">rx3f</span><span class="p">])</span>
<span class="c"># print using a list comprehension</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">False roots:&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;f({0:0.5f}) = {1:0.2e}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tdl</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rxf</span><span class="p">))</span>

<span class="c"># Plot function and various roots</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">tdl</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c"># Create masked array for plotting</span>
<span class="n">ymask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">20.</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ymask</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&quot;gray&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">3.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&quot;gray&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">5.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&quot;gray&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">r&#39;$x$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">r&#39;$\tan x - \sqrt{(8/x)^2-1}$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="s">&#39;og&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;true roots&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rxf</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="s">&#39;xr&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;false roots&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">numpoints</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s">&#39;small&#39;</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="s">&#39;upper right&#39;</span><span class="p">,</span>
           <span class="n">bbox_to_anchor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.92</span><span class="p">,</span> <span class="mf">0.97</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Running this code generates the following output:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="n">run</span> <span class="n">rootbrentq</span><span class="o">.</span><span class="n">py</span>

<span class="go">True roots:</span>
<span class="go">f(1.39547) = -6.39e-14</span>
<span class="go">f(4.16483) = -7.95e-14</span>
<span class="go">f(6.83067) = -1.11e-15</span>

<span class="go">False roots:</span>
<span class="go">f(1.57080) = -1.61e+12</span>
<span class="go">f(4.71239) = -1.56e+12</span>
<span class="go">f(7.85398) = 1.16e+12</span>
</pre></div>
</div>
<p>The Brent method finds the three true roots of the equation quickly and accurately when you provide values for the brackets <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> that are valid.  However, like many numerical methods for finding roots, the Brent method can produce spurious roots as it does in the above example when <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> bracket singularities like those at <img class="math" src="../_images/math/60a43d3f0afa4960a07aa6bd95f7ee6a0e736540.png" alt="x = \{\pi/2, 3\pi/2, 5\pi/2\}"/>.  Here we evaluated the function at the purported roots found by <tt class="docutils literal"><span class="pre">brentq</span></tt> to verify that the values of <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> found were indeed roots.  For the true roots, the values of the function were very near zero, to within an acceptable roundoff error of less than <img class="math" src="../_images/math/1a3a2dab816675417c206c81ff09099b5f0a25ff.png" alt="10^{-13}"/>.  For the false roots, exceedingly large numbers on the order of  <img class="math" src="../_images/math/b4b238f0f085c6843273ec1babb3460deae99fea.png" alt="10^{12}"/> were obtained, indicating a possible problem with these roots.  These results, together with the plots, allow you to unambiguously identify the true solutions to this nonlinear function.</p>
<p>The <tt class="docutils literal"><span class="pre">brentq</span></tt> function has a number of optional keyword arguments that you may find useful.  One keyword argument causes <tt class="docutils literal"><span class="pre">brentq</span></tt> to return not only the solution but the value of the function evaluated at the solution.  Other arguments allow you to specify a tolerance to which the solution is found as well as a few other parameters possibly of interest.  Most of the time, you can leave the keyword arguments at their default values.  See the <tt class="docutils literal"><span class="pre">brentq</span></tt> entry online on the SciPy web site for more information.</p>
</div>
<div class="section" id="other-methods-for-solving-equations-of-a-single-variable">
<span id="index-14"></span><h4>9.6.1.2. Other methods for solving equations of a single variable<a class="headerlink" href="#other-methods-for-solving-equations-of-a-single-variable" title="Permalink to this headline">¶</a></h4>
<p>SciPy provides a number of other methods for solving nonlinear equations of a single variable.  It has an implementation of the Newton-Raphson method called <tt class="docutils literal"><span class="pre">scipy.optimize.newton</span></tt>.  It&#8217;s the racecar of such methods; its super fast but less stable that the Brent method.  To fully realize its speed, you need to specify not only the function to be solved, but also its first derivative, which is often more trouble than its worth.  You can also specify its second derivative, which may further speed up finding the solution.  If you do not specify the first or second derivatives, the method uses the secant method, which is usually slower than the Brent method.</p>
<p id="index-15">Other methods, including the Ridder (<tt class="docutils literal"><span class="pre">scipy.optimize.ridder</span></tt>) and bisection (<tt class="docutils literal"><span class="pre">scipy.optimize.bisect</span></tt>), are also available, although the Brent method is generally superior.  SciPy let&#8217;s you use your favorite.</p>
</div>
</div>
<div class="section" id="solving-systems-of-nonlinear-equations">
<span id="index-16"></span><h3>9.6.2. Solving systems of nonlinear equations<a class="headerlink" href="#solving-systems-of-nonlinear-equations" title="Permalink to this headline">¶</a></h3>
<p>Solving systems of nonlinear equations is not for the faint of heart.  It is a difficult problem that lacks any general purpose solutions.  Nevertheless, SciPy provides quite an assortment of numerical solvers for nonlinear systems of equations.  However, because of the complexity and subtleties of this class of problems, we do not discuss their use here.</p>
</div>
</div>
<div class="section" id="exercises">
<h2>9.7. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Use NumPy&#8217;s <tt class="docutils literal"><span class="pre">polyval</span></tt> function together with SciPy to plot the following functions:<ol class="loweralpha">
<li>The first four Chebyshev polynomials of first kind.  Plot these over the interval from -1 to +1.</li>
<li>The first four Hermite polynomials  <em>multiplied</em> by <img class="math" src="../_images/math/f108f4084f1e6813a3d782a2b3a67de7a3bd2dbd.png" alt="e^{-x^2/2}"/>.  Plot these on the interval from -5 to +5.  These are the first four wave functions of the quantum mechanical simple harmonic oscillator.</li>
</ol>
</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chap1/chap1_intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chap2/chap2_basics.html">2. Launching Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chap3/chap3_arrays.html">3. Strings, Lists, Arrays, and Dictionaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chap4/chap4_io.html">4. Input and Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chap5/chap5_plot.html">5. Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chap6/chap6_loopsconds.html">6. Conditionals and Loops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chap7/chap7_funcs.html">7. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chap8/chap8_fitting.html">8. Curve Fitting</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">9. Numerical Routines: SciPy and NumPy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#special-functions">9.1. Special functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#numerical-integration">9.2. Numerical integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#solving-odes">9.3. Solving ODEs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discrete-fast-fourier-transforms">9.4. Discrete (fast) Fourier transforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linear-algebra">9.5. Linear algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="#solving-non-linear-equations">9.6. Solving non-linear equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">9.7. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../apdx1/apdx1_install.html">10. Installing Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apdx2/apdx2_ipynb.html">11. IPython Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apdx3/apdx3_resources.html">12. Python Resources</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../chap8/chap8_fitting.html" title="8. Curve Fitting"
             >previous</a> |
          <a href="../apdx1/apdx1_install.html" title="10. Installing Python"
             >next</a> |
          <a href="../genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="../_sources/chap9/chap9_scipy.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2014, David J. Pine.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>